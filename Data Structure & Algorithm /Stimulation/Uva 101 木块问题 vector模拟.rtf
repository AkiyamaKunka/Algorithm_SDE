{\rtf1\ansi\ansicpg1252\cocoartf2511
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red251\green24\blue39;\red190\green0\blue135;\red14\green110\blue109;
\red82\green72\blue255;\red16\green131\blue255;}
{\*\expandedcolortbl;;\csgenericrgb\c98431\c9412\c15294;\csgenericrgb\c74510\c0\c52941;\csgenericrgb\c5490\c43137\c42745;
\csgenericrgb\c32157\c28235\c100000;\csgenericrgb\c6275\c51373\c100000;}
\paperw11900\paperh16840\margl1440\margr1440\vieww21600\viewh17400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs24 \cf1 \cb0 #include \cf2 <iostream>\
\cf1 #include \cf2 <cstring>\
\cf1 #include \cf2 <complex>\
\cf1 #include \cf2 <cstdlib>\
\cf1 #include \cf2 <vector>\
\cf1 #include \cf2 <fstream>\
\cf1 #include \cf2 <queue>\
\cf1 #include \cf2 <cmath>\
\cf1 #include \cf2 <algorithm>\
\cf1 #include \cf2 <cstdio>\
\
\cf3 using namespace \cf4 std\cf1 ;\
#define LOCAL\
\cf3 const int \cf1 maxn = \cf5 30\cf1 ;\
\cf4 vector \cf1 <\cf3 int\cf1 > loc[maxn];\
\cf3 int \cf1 num;\
\
\cf3 void \cf6 search\cf1 (\cf3 int \cf1 a, \cf3 int \cf1 & p, \cf3 int \cf1 & h)\{\
    \cf3 for \cf1 (p = \cf5 0\cf1 ; ; p++)\
        \cf3 for \cf1 ( h = \cf5 0\cf1 ; h<loc[p].\cf6 size\cf1 (); h++)\{\
            \cf3 if\cf1 (loc[p]\cf4 [\cf1 h\cf4 ]\cf1 ==a ) \cf3 return \cf1 ;\
        \}\
\}\
\
\cf3 void \cf6 turnBack\cf1 (\cf3 int \cf1 p,\cf3 int \cf1 h)\{\
    \cf3 int \cf1 size= loc[p].\cf6 size\cf1 ()-h;\
    \cf3 for \cf1 (\cf3 int \cf1 i = \cf5 0\cf1 ; i < size; i++)\{\
        \cf3 int \cf1 temp = loc[p].\cf6 back\cf1 ();\
        loc[temp].\cf6 insert\cf1 (loc[temp].\cf6 begin\cf1 (),temp);\
        loc[p].\cf6 pop_back\cf1 ();\
    \}\
\}\
\
\cf3 void \cf6 fun1\cf1 (\cf3 int \cf1 a,\cf3 int \cf1 b)\{\
    \cf3 int \cf1 p1,h1,p2,h2;\
    \cf6 search\cf1 (a,p1,h1);\
    \cf6 search\cf1 (b,p2,h2);\
    \cf6 turnBack\cf1 (p1,h1);\
    \cf6 turnBack\cf1 (p2,h2);\
    loc[p2].\cf6 push_back\cf1 (loc[p1]\cf4 [\cf1 h1\cf4 ]\cf1 );\
    loc[p1].\cf6 pop_back\cf1 ();\
\}\
\cf3 void \cf6 fun2\cf1 (\cf3 int \cf1 a,\cf3 int \cf1 b)\{\
    \cf3 int \cf1 p1,h1,p2,h2;\
    \cf6 search\cf1 (a,p1,h1);\
    \cf6 search\cf1 (b,p2,h2);\
    \cf6 turnBack\cf1 (p1,h1);\
    loc[p2].\cf6 push_back\cf1 (loc[p1]\cf4 [\cf1 h1\cf4 ]\cf1 );\
    loc[p1].\cf6 pop_back\cf1 ();\
\}\
\cf3 void \cf6 fun3\cf1 (\cf3 int \cf1 a,\cf3 int \cf1 b)\{\
    \cf3 int \cf1 p1,h1,p2,h2;\
    \cf6 search\cf1 (a,p1,h1);\
    \cf6 search\cf1 (b,p2,h2);\
    \cf6 turnBack\cf1 (p2,h2);\
    \cf3 int \cf1 size =loc[p1].\cf6 size\cf1 ()-h1;\
    \cf3 for \cf1 ( \cf3 int \cf1 i = \cf5 0\cf1 ;  i< size; i++)\{\
        loc[p2].\cf6 push_back\cf1 (loc[p1]\cf4 [\cf1 h1\cf4 ]\cf1 );\
        loc[p1].\cf6 erase\cf1 (loc[p1].\cf6 begin\cf1 ()\cf4 +\cf1 h1,loc[p1].\cf6 begin\cf1 ()\cf4 +\cf1 h1\cf4 +\cf5 1\cf1 );\
    \}\
\}\
\
\cf3 void \cf6 fun4\cf1 (\cf3 int \cf1 a,\cf3 int \cf1 b)\{\
    \cf3 int \cf1 p1,h1,p2,h2;\
    \cf6 search\cf1 (a,p1,h1);\
    \cf6 search\cf1 (b,p2,h2);\
    \cf3 int \cf1 size =loc[p1].\cf6 size\cf1 ()-h1;\
    \cf3 for \cf1 ( \cf3 int \cf1 i = \cf5 0\cf1 ;  i< size; i++)\{\
        loc[p2].\cf6 push_back\cf1 (loc[p1]\cf4 [\cf1 h1\cf4 ]\cf1 );\
        loc[p1].\cf6 erase\cf1 (loc[p1].\cf6 begin\cf1 ()\cf4 +\cf1 h1,loc[p1].\cf6 begin\cf1 ()\cf4 +\cf1 h1\cf4 +\cf5 1\cf1 );\
    \}\
\}\
\
\cf3 int \cf6 main\cf1 ()\{\
#ifdef LOCAL\
    \cf6 freopen\cf1 (\cf2 "try3.txt"\cf1 ,\cf2 "r"\cf1 ,stdin);\
    \cf6 freopen\cf1 (\cf2 "data_in.txt"\cf1 ,\cf2 "w"\cf1 ,stdout);\
#endif\
    cin\cf4 >>\cf1 num;\
    \cf3 for \cf1 (\cf3 int \cf1 i = \cf5 0\cf1 ; i < num; i++)\
        loc[i].\cf6 push_back\cf1 (i);\
    \cf3 int \cf1 order,a,b;\
    \cf3 while\cf1 (cin\cf4 >>\cf1 order\cf4 >>\cf1 a\cf4 >>\cf1 b)\{\
        \cf3 switch \cf1 (order)\{\
            \cf3 case \cf5 1\cf1 :\{ \cf6 fun1\cf1 (a,b);\cf3 break\cf1 ;\}\
            \cf3 case \cf5 2\cf1 :\{ \cf6 fun2\cf1 (a,b);\cf3 break\cf1 ;\}\
            \cf3 case \cf5 3\cf1 :\{ \cf6 fun3\cf1 (a,b);\cf3 break\cf1 ;\}\
            \cf3 case \cf5 4\cf1 :\{ \cf6 fun4\cf1 (a,b);\cf3 break\cf1 ;\}\
            \cf3 default \cf1 : \{cout\cf4 <<\cf2 "Input error."\cf1 ;\cf3 break\cf1 ;\}\
        \}\
    \}\
    \cf3 for \cf1 (\cf3 int \cf1 j = \cf5 0\cf1 ; j <num ; j++)\{\
        \cf3 for \cf1 (\cf3 int \cf1 i = \cf5 0\cf1 ; i < loc[j].\cf6 size\cf1 (); i++)\{\
            cout\cf4 <<\cf1 loc[j]\cf4 [\cf1 i\cf4 ]<<\cf2 " "\cf1 ;\
        \}\
        cout\cf4 <<\cf6 endl\cf1 ;\
    \}\
\
        \cf3 return \cf5 0\cf1 ;\
\}\
\
}